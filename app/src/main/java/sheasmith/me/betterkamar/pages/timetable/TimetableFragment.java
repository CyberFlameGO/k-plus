/*
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "[]"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright 2020 Shea Smith
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 */

package sheasmith.me.betterkamar.pages.timetable;

import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.core.content.res.ResourcesCompat;
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import android.view.ContextThemeWrapper;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;


import com.google.firebase.analytics.FirebaseAnalytics;
import com.prolificinteractive.materialcalendarview.CalendarDay;
import com.prolificinteractive.materialcalendarview.MaterialCalendarView;
import com.prolificinteractive.materialcalendarview.OnDateSelectedListener;
import com.prolificinteractive.materialcalendarview.format.TitleFormatter;

import org.threeten.bp.Instant;
import org.threeten.bp.ZoneId;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import sheasmith.me.betterkamar.KamarPlusApplication;
import sheasmith.me.betterkamar.R;
import sheasmith.me.betterkamar.dataModels.AbsenceObject;
import sheasmith.me.betterkamar.dataModels.AttendanceObject;
import sheasmith.me.betterkamar.dataModels.CalendarObject;
import sheasmith.me.betterkamar.dataModels.EventsObject;
import sheasmith.me.betterkamar.dataModels.GlobalObject;
import sheasmith.me.betterkamar.dataModels.LoginObject;
import sheasmith.me.betterkamar.dataModels.TimetableObject;
import sheasmith.me.betterkamar.internalModels.ApiResponse;
import sheasmith.me.betterkamar.internalModels.Exceptions;
import sheasmith.me.betterkamar.internalModels.PortalObject;
import sheasmith.me.betterkamar.util.ApiManager;
import sheasmith.me.betterkamar.util.OnSwipeTouchListener;

import static android.view.View.GONE;

public class TimetableFragment extends Fragment {

    private RecyclerView mRecyclerView;
    private TimetableAdapter mAdapter;
    private ProgressBar mLoader;
    private TextView noEvents;
    private MaterialCalendarView mCalendarView;

    private ArrayList<GlobalObject.PeriodDefinition> periodDefinitions;
    private ArrayList<GlobalObject.Day> periodDays;
    private ArrayList<AttendanceObject.Week> attendanceResults;
    private ArrayList<EventsObject.Event> events;
    private ArrayList<TimetableObject.Week> timetable;
    private ArrayList<CalendarObject.Day> days;
    private AbsenceObject absenceStats;
    private Date lastDate;
    private PortalObject mPortal;
    private SwipeRefreshLayout mSwipeRefreshLayout;
    private ImageView art;
    private View mView;

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        if (isAdded()) {
            ((AppCompatActivity) requireActivity()).getSupportActionBar().setElevation(10);
            requireActivity().setTitle("Timetable");
            if (mAdapter == null || mAdapter.getItemCount() == 0)
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        doRequest(mPortal, false);
                    }
                }).start();
            requireActivity().invalidateOptionsMenu();

            KamarPlusApplication application = (KamarPlusApplication) requireActivity().getApplication();

            FirebaseAnalytics.getInstance(requireActivity()).setCurrentScreen(requireActivity(), "Timetable", null);
        }
    }

    public static TimetableFragment newInstance() {
        return new TimetableFragment();
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            periodDefinitions = (ArrayList<GlobalObject.PeriodDefinition>) savedInstanceState.getSerializable("periodDefinitions");
            attendanceResults = (ArrayList<AttendanceObject.Week>) savedInstanceState.getSerializable("attendanceResults");
            events = (ArrayList<EventsObject.Event>) savedInstanceState.getSerializable("events");
            timetable = (ArrayList<TimetableObject.Week>) savedInstanceState.getSerializable("timetable");
            days = (ArrayList<CalendarObject.Day>) savedInstanceState.getSerializable("days");

            if (savedInstanceState.containsKey("selectedDate"))
                lastDate = (Date) savedInstanceState.getSerializable("selectedDate");
        }

        if (isAdded()) {
            mPortal = (PortalObject) requireActivity().getIntent().getSerializableExtra("portal");
            ApiManager.setVariables(mPortal, requireContext());
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (isAdded()) {
            if (item.getItemId() == 1) {
                AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
                builder.setTitle("Attendance Statistics").setPositiveButton("close", null);
                if (absenceStats == null) {
                    builder.setMessage("Please wait for the timetable to load");
                } else {
                    AbsenceObject.Student student = absenceStats.StudentAbsenceStatsResults.Student;
                    builder.setMessage(String.format("Unjustified: %s%%\nJustified: %s%%\nOverseas: %s%%\nTotal Absences: %s%%\nTotal Present: %s%%", student.PctgeU, student.PctgeJ, student.PctgeO, student.PctgeT, student.PctgeP));
                }
                builder.create().show();
            } else if (item.getItemId() == 2) {
                LayoutInflater inflater = getLayoutInflater();
                View contentView = inflater.inflate(R.layout.timetable_info, null);

                new AlertDialog.Builder(requireContext())
                        .setTitle("Attendance Codes (based on MoE rules)")
                        .setView(contentView)
                        .setPositiveButton("Close", null)
                        .create()
                        .show();
            }
        }

        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        menu.clear();
        menu.add(0, 1, 0, "Attendance Stats").setIcon(R.drawable.ic_chart).setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
        menu.add(0, 2, 0, "Attendance Info").setIcon(R.drawable.ic_info).setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
        super.onPrepareOptionsMenu(menu);
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        if (isAdded()) {
            SharedPreferences sharedPreferences = requireContext().getSharedPreferences("ThemeColours", Context.MODE_PRIVATE);
            String stringColor = sharedPreferences.getString("color", "E65100");

            final Context contextThemeWrapper = new ContextThemeWrapper(requireActivity(), getResources().getIdentifier("T_" + stringColor, "style", requireContext().getPackageName()));

            LayoutInflater localInflator = inflater.cloneInContext(contextThemeWrapper);
            View view = localInflator.inflate(R.layout.fragment_timetable, container, false);
            mLoader = view.findViewById(R.id.progressBar);
            noEvents = view.findViewById(R.id.noEvents);
            art = view.findViewById(R.id.art);
            setHasOptionsMenu(true);

            mView = view;

            mRecyclerView = view.findViewById(R.id.events);
            mRecyclerView.setOnTouchListener(new OnSwipeTouchListener(requireContext()) {
                @Override
                public void onSwipeRight() {
                    mCalendarView.setCurrentDate(mCalendarView.getSelectedDate().getDate().minusDays(1));
                    mCalendarView.setSelectedDate(mCalendarView.getSelectedDate().getDate().minusDays(1));
                    final Date date = new Date(mCalendarView.getSelectedDate().getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }

                @Override
                public void onSwipeLeft() {
                    mCalendarView.setCurrentDate(mCalendarView.getSelectedDate().getDate().plusDays(1));
                    mCalendarView.setSelectedDate(mCalendarView.getSelectedDate().getDate().plusDays(1));
                    final Date date = new Date(mCalendarView.getSelectedDate().getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }
            });

            noEvents.setOnTouchListener(new OnSwipeTouchListener(requireContext()) {
                @Override
                public void onSwipeRight() {
                    mCalendarView.setCurrentDate(mCalendarView.getSelectedDate().getDate().minusDays(1));
                    mCalendarView.setSelectedDate(mCalendarView.getSelectedDate().getDate().minusDays(1));
                    final Date date = new Date(mCalendarView.getSelectedDate().getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }

                @Override
                public void onSwipeLeft() {
                    mCalendarView.setCurrentDate(mCalendarView.getSelectedDate().getDate().plusDays(1));
                    mCalendarView.setSelectedDate(mCalendarView.getSelectedDate().getDate().plusDays(1));
                    final Date date = new Date(mCalendarView.getSelectedDate().getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }
            });

            art.setOnTouchListener(new OnSwipeTouchListener(requireContext()) {
                @Override
                public void onSwipeRight() {
                    mCalendarView.setCurrentDate(mCalendarView.getSelectedDate().getDate().minusDays(1));
                    mCalendarView.setSelectedDate(mCalendarView.getSelectedDate().getDate().minusDays(1));
                    final Date date = new Date(mCalendarView.getSelectedDate().getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }

                @Override
                public void onSwipeLeft() {
                    mCalendarView.setCurrentDate(mCalendarView.getSelectedDate().getDate().plusDays(1));
                    mCalendarView.setSelectedDate(mCalendarView.getSelectedDate().getDate().plusDays(1));
                    final Date date = new Date(mCalendarView.getSelectedDate().getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }
            });

            // use this setting to improve performance if you know that changes
            // in content do not change the layout size of the RecyclerView
            mRecyclerView.setHasFixedSize(false);

            // use a linear layout manager
            RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(requireContext());
            mRecyclerView.setLayoutManager(mLayoutManager);

            Date now = new Date(System.currentTimeMillis());
            Calendar cal = Calendar.getInstance();
            cal.setTime(now);

            cal.set(Calendar.MILLISECOND, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.HOUR, 0);
            cal.set(Calendar.MONTH, 0);
            cal.set(Calendar.DAY_OF_MONTH, 1);

            Date min = cal.getTime();

            cal.set(Calendar.MONTH, 11);
            cal.set(Calendar.DAY_OF_MONTH, 31);

            Date max = cal.getTime();

            mCalendarView = view.findViewById(R.id.calendarView);
//        mCalendarView.setCurrentDate(new Date(System.currentTimeMillis()));
            mCalendarView.state().edit().setMaximumDate(Instant.ofEpochMilli(max.getTime()).atZone(ZoneId.systemDefault()).toLocalDate()).setMinimumDate(Instant.ofEpochMilli(min.getTime()).atZone(ZoneId.systemDefault()).toLocalDate()).commit();

            mCalendarView.setOnDateChangedListener(new OnDateSelectedListener() {
                @Override
                public void onDateSelected(@NonNull MaterialCalendarView widget, @NonNull CalendarDay calDate, boolean selected) {
                    final Date date = new Date(calDate.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
                    updateList(date);
                }
            });

            if (lastDate != null) {
                mCalendarView.setSelectedDate(Instant.ofEpochMilli(lastDate.getTime()).atZone(ZoneId.systemDefault()).toLocalDate());
                updateList(lastDate);
            }

            mSwipeRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.swipe_container);
            mSwipeRefreshLayout.setColorSchemeColors(getResources().getColor(R.color.colorAccent));
            SwipeRefreshLayout.OnRefreshListener listener = new SwipeRefreshLayout.OnRefreshListener() {
                @Override
                public void onRefresh() {
                    doRequest(mPortal, true);
                }
            };
            mSwipeRefreshLayout.setOnRefreshListener(listener);

            Button noInternetRetry = mView.findViewById(R.id.no_internet_retry);
            noInternetRetry.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    mSwipeRefreshLayout.setRefreshing(true);
                    listener.onRefresh();
                    mView.findViewById(R.id.noInternet).setVisibility(GONE);
                }
            });

            mCalendarView.setLeftArrow(R.drawable.calendar_previous);
            mCalendarView.setRightArrow(R.drawable.calendar_next);


            return view;
        }
        return inflater.inflate(R.layout.fragment_timetable, container, false);
    }


    private void doRequest(final PortalObject portal, final boolean ignoreCache) {
        final boolean[] finished = new boolean[]{false, false, false, false, false, false};

        ApiManager.getGlobals(new ApiResponse<GlobalObject>() {
            @Override
            public void success(GlobalObject value) {
                if (isAdded()) {
                    periodDefinitions = value.GlobalsResults.PeriodDefinitions;
                    periodDays = value.GlobalsResults.StartTimes;
                    finished[0] = true;
                    hideLoader(finished);
                }
            }

            @Override
            public void error(Exception e) {
                e.printStackTrace();
                finished[0] = true;
                handleError(portal, e, ignoreCache);
            }

        }, ignoreCache);

        ApiManager.getAttendance(new ApiResponse<AttendanceObject>() {
            @Override
            public void success(AttendanceObject value) {
                if (isAdded()) {
                    attendanceResults = value.StudentAttendanceResults.Weeks;
                    finished[1] = true;
                    hideLoader(finished);
                }
            }

            @Override
            public void error(Exception e) {
                e.printStackTrace();
                finished[1] = true;
                handleError(portal, e, ignoreCache);
            }
        }, ignoreCache);

        ApiManager.getEvents(new ApiResponse<EventsObject>() {
            @Override
            public void success(EventsObject value) {
                if (isAdded()) {
                    events = value.EventsResults.Events;
                    finished[2] = true;
                    hideLoader(finished);
                }
            }

            @Override
            public void error(Exception e) {
                e.printStackTrace();
                finished[2] = true;
                handleError(portal, e, ignoreCache);
            }
        }, Calendar.getInstance().get(Calendar.YEAR), ignoreCache);

        ApiManager.getTimetable(new ApiResponse<TimetableObject>() {
            @Override
            public void success(TimetableObject value) {
                if (isAdded()) {
                    timetable = value.StudentTimetableResults.Student.Timetable;
                    finished[3] = true;
                    hideLoader(finished);
                }
            }

            @Override
            public void error(Exception e) {
                e.printStackTrace();
                finished[3] = true;

                handleError(portal, e, ignoreCache);
            }
        }, ignoreCache);

        ApiManager.getCalendar(new ApiResponse<CalendarObject>() {
            @Override
            public void success(CalendarObject value) {
                if (isAdded()) {
                    days = value.CalendarResults.Days;
                    finished[4] = true;
                    hideLoader(finished);
                }
            }

            @Override
            public void error(Exception e) {
                e.printStackTrace();
                finished[4] = true;

                handleError(portal, e, ignoreCache);
            }
        }, ignoreCache);

        ApiManager.getAbsenceStats(new ApiResponse<AbsenceObject>() {
            @Override
            public void success(AbsenceObject value) {
                if (isAdded()) {
                    absenceStats = value;
                    finished[5] = true;
                    hideLoader(finished);
                }
            }

            @Override
            public void error(Exception e) {
                e.printStackTrace();
                finished[5] = true;

                handleError(portal, e, ignoreCache);
            }
        }, ignoreCache);
    }

    private void handleError(final PortalObject portal, Exception e, final boolean ignoreCache) {
        if (e instanceof Exceptions.ExpiredToken) {
            ApiManager.login(portal.username, portal.password, new ApiResponse<LoginObject>() {
                @Override
                public void success(LoginObject value) {
                    doRequest(portal, ignoreCache);
                }

                @Override
                public void error(Exception e) {
                    e.printStackTrace();
                }
            });
            return;
        } else if (e instanceof IOException) {
            if (isAdded())
                requireActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mSwipeRefreshLayout.setRefreshing(false);
                        mView.findViewById(R.id.noInternet).setVisibility(View.VISIBLE);
                        art.setVisibility(View.GONE);
                        noEvents.setVisibility(View.GONE);
                        mRecyclerView.setVisibility(View.GONE);
                    }
                });
        } else if (e instanceof Exceptions.AccessDenied) {
            if (isAdded()) {
                requireActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        new AlertDialog.Builder(requireActivity())
                                .setTitle("Access Denied")
                                .setMessage("Your school has disabled access to this section. You may still be able to view it via the web portal.")
                                .setPositiveButton("Retry", new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick(DialogInterface dialogInterface, int i) {
                                        doRequest(portal, ignoreCache);
                                    }
                                })
                                .setNegativeButton("Cancel", null)
                                .create()
                                .show();
                    }
                });
            }
        }
    }

    private void hideLoader(boolean[] finished) {
        for (boolean f : finished) {
            if (!f)
                return;
        }
        if (isAdded()) {
            requireActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mLoader.setVisibility(View.GONE);
                    mSwipeRefreshLayout.setRefreshing(false);
                    // So we get the weeks to show up
                    mCalendarView.setCurrentDate(mCalendarView.getCurrentDate().getDate().minusWeeks(1));
                    mCalendarView.setCurrentDate(mCalendarView.getCurrentDate().getDate().plusWeeks(1));
                    mCalendarView.setSelectedDate(Instant.ofEpochMilli(System.currentTimeMillis()).atZone(ZoneId.systemDefault()).toLocalDate());
                    mRecyclerView.setVisibility(View.VISIBLE);
                    mView.findViewById(R.id.noInternet).setVisibility(View.GONE);
                    updateList(new Date(System.currentTimeMillis()));
                }
            });
        }
    }

    private void updateList(final Date date) {
        Calendar current = Calendar.getInstance();
        current.setTime(date);

        List<TimetableObject.Class> periods = new ArrayList<>();
        List<GlobalObject.PeriodTime> times = new ArrayList<>();
        Calendar monday = Calendar.getInstance();
        monday.setTime(date);
        monday.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
        final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");

        int weekNumber = 0;
        CalendarObject.Day thisDay = null;
        final Calendar temp = Calendar.getInstance();

        AttendanceObject.Week attendanceWeek = null;

        HashMap<String, List<CalendarDay>> dotsSortedByType = new HashMap<>();

        if (days != null) {
            for (CalendarObject.Day day : days) {
                try {

                    Date start = format.parse(day.Date);
                    temp.setTime(start);

                    List<CalendarDay> tempList = new ArrayList<>();
                    if (dotsSortedByType.containsKey(day.Status))
                        tempList = dotsSortedByType.get(day.Status);

                    tempList.add(CalendarDay.from(temp.get(Calendar.YEAR), temp.get(Calendar.MONTH) + 1, temp.get(Calendar.DAY_OF_MONTH)));

                    dotsSortedByType.put(day.Status, tempList);

                    if (current.get(Calendar.DAY_OF_YEAR) == temp.get(Calendar.DAY_OF_YEAR) && !day.WeekYear.equals("") && !day.Status.equals("Holidays")) {
                        weekNumber = Integer.parseInt(day.WeekYear);
                        if (attendanceResults != null) {
                            for (AttendanceObject.Week aw : attendanceResults) {
                                Date weekStart = format.parse(aw.WeekStart);
                                Calendar weekCal = Calendar.getInstance();
                                weekCal.setTime(weekStart);
                                if (weekCal.get(Calendar.DAY_OF_YEAR) == monday.get(Calendar.DAY_OF_YEAR) && weekCal.get(Calendar.YEAR) == monday.get(Calendar.YEAR)) {
                                    attendanceWeek = aw;
                                }
                            }
                        }
                        thisDay = day;
                    } else if (current.get(Calendar.DAY_OF_YEAR) == temp.get(Calendar.DAY_OF_YEAR)) {
                        thisDay = day;
                    }

                } catch (ParseException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        for (Map.Entry<String, List<CalendarDay>> entry : dotsSortedByType.entrySet()) {
            int color;
            switch (entry.getKey()) {
                case "Holidays":
                    color = ResourcesCompat.getColor(getResources(), R.color.merit, null);
                    break;
                case "Holiday":
                    color = ResourcesCompat.getColor(getResources(), R.color.merit, null);
                    break;
                case "Open":
                    color = ResourcesCompat.getColor(getResources(), R.color.achieved, null);
                    break;
                case "Teacher Only Day":
                    color = ResourcesCompat.getColor(getResources(), R.color.excellence, null);
                    break;
                case "School Closed":
                    color = ResourcesCompat.getColor(getResources(), R.color.notachieved, null);
                    break;
                default:
                    color = -1;
                    break;
            }

            if (color != -1)
                mCalendarView.addDecorator(new DayTypeDecorator(color, entry.getValue()));
        }

        if (thisDay != null) {
            final CalendarObject.Day finalThisDay = thisDay;
            if (isAdded()) {
                requireActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
//                    if (finalThisDay.Week.equals("") || finalThisDay.DayTT.equals("")) {
//                    }
//                    else {
//                        status.setText(String.format("School Status: %s. Term %s Week %s", finalThisDay.Status, finalThisDay.Term, finalThisDay.Week));
//                    }


                        mCalendarView.setTitleFormatter(new TitleFormatter() {
                            @Override
                            public CharSequence format(CalendarDay calendarDay) {
                                SimpleDateFormat form = new SimpleDateFormat("MMMM, yyyy");
                                CalendarObject.Day weekDay = null;
                                int dayOfYear = mCalendarView.getCurrentDate().getDate().getDayOfYear();
                                for (CalendarObject.Day day : days) {
                                    try {
                                        Date start = format.parse(day.Date);
                                        temp.setTime(start);
                                        if (dayOfYear == temp.get(Calendar.DAY_OF_YEAR)) {
                                            weekDay = day;
                                        }

                                    } catch (ParseException e) {
                                        throw new RuntimeException(e);
                                    }
                                }
                                if (weekDay.Status.equals("Holidays"))
                                    return form.format(new Date(calendarDay.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()));
                                else
                                    return form.format(new Date(calendarDay.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli())) + "\nTerm " + weekDay.TermA + " Week " + weekDay.WeekA;
                            }
                        });
                        mCalendarView.invalidate();
                    }
                });
            }
        }

        if (weekNumber == 0) {
            if (isAdded()) {
                requireActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mRecyclerView.setVisibility(View.GONE);
                        noEvents.setVisibility(View.VISIBLE);
                        noEvents.setText("There are no events or classes on the day you selected");
                        art.setVisibility(View.GONE);
                    }
                });
            }
            return;
        } else {
            if (isAdded()) {
                requireActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mRecyclerView.setVisibility(View.VISIBLE);
                        noEvents.setVisibility(View.GONE);
                        art.setVisibility(View.GONE);
                    }
                });
            }
        }

        AttendanceObject.Day attendanceDay = null;

        if (timetable != null) {
            weekLoop:
            for (TimetableObject.Week week : timetable) {
                if (week.WeekNumber == weekNumber) {
                    for (Integer day : week.Classes.keySet()) {
                        Calendar cal = Calendar.getInstance();
                        cal.setFirstDayOfWeek(Calendar.SUNDAY);
                        cal.setTime(date);
                        cal.set(Calendar.HOUR_OF_DAY, 0);
                        cal.set(Calendar.MINUTE, 0);
                        cal.set(Calendar.SECOND, 0);
                        cal.set(Calendar.MILLISECOND, 0);
                        cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
                        cal.add(Calendar.DAY_OF_WEEK, day);

                        if (cal.get(Calendar.DAY_OF_YEAR) == current.get(Calendar.DAY_OF_YEAR)) {
                            periods = week.Classes.get(day);

                            times = null;
                            for (GlobalObject.Day periodDay : periodDays) {
                                if (Integer.parseInt(periodDay.index) == day) {
                                    times = periodDay.PeriodTimes;
                                    break;
                                }
                            }

                            if (attendanceWeek != null) {
                                for (AttendanceObject.Day ad : attendanceWeek.Days) {
                                    if (ad.index.equals(day.toString())) {
                                        attendanceDay = ad;
                                        break;
                                    }
                                }
                            }
                            break weekLoop;
                        }
                    }
                }
            }
        }

        if (periods != null) {
            for (TimetableObject.Class c : periods) {
                if (attendanceDay != null) {
                    try {
                        c.attendance = attendanceDay.content.charAt(periods.indexOf(c));
                    } catch (IndexOutOfBoundsException e) {
                        c.attendance = '.';
                    }
                } else
                    break;
            }
        }

        final List<EventsObject.Event> dayEvents = new ArrayList<>();

        if (events != null) {
            for (EventsObject.Event event : events) {
                try {
                    Date start = format.parse(event.Start);
                    Date end = format.parse(event.Finish);

                    Calendar c = Calendar.getInstance();
                    c.setTime(start);
                    int startDay = c.get(Calendar.DAY_OF_YEAR);

                    c.setTime(end);
                    int endDay = c.get(Calendar.DAY_OF_YEAR);

                    c.setTime(date);
                    int currentDay = c.get(Calendar.DAY_OF_YEAR);

                    if (startDay >= currentDay && endDay <= currentDay) {
                        dayEvents.add(event);
                    }
                } catch (ParseException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        if (periods == null) {
            throw new RuntimeException();
        }

        if (dayEvents.size() == 0 && periods.size() == 0) {
            if (isAdded()) {
                CalendarObject.Day finalThisDay1 = thisDay;
                requireActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mRecyclerView.setVisibility(View.GONE);
                        noEvents.setVisibility(View.VISIBLE);
                        art.setVisibility(View.GONE);

                        int image;
                        String text;
                        switch (finalThisDay1.Status) {
                            case "Holidays":
                                image = R.drawable.holiday;
                                text = "School Holidays";
                                break;
                            case "Holiday":
                                image = R.drawable.holiday;
                                text = "School Holidays";
                                break;
                            case "Teacher Only Day":
                                image = R.drawable.closed;
                                text = "Teachers Only Day";
                                break;
                            case "School Closed":
                                image = R.drawable.closed;
                                text = "School Closed";
                                break;
                            case "Weekend":
                                image = R.drawable.weekend;
                                text = "Weekend";
                                break;
                            default:
                                image = -1;
                                text = "There are no events or classes on the day you selected";
                                break;
                        }

                        if (image != -1) {
                            art.setVisibility(View.VISIBLE);
                            art.setImageResource(image);
                        }

                        noEvents.setText(text);
                    }
                });
            }
            return;
        }

        final List<TimetableObject.Class> finalPeriods = periods;
        if (isAdded()) {
            List<GlobalObject.PeriodTime> finalTimes = times;
            requireActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    if (isAdded()) {
                        mAdapter = new TimetableAdapter(dayEvents, finalPeriods, periodDefinitions, finalTimes, requireContext());
                        mRecyclerView.setAdapter(mAdapter);
//                                                mLoader.setVisibility(View.GONE);
                    }
                }
            });
        }
    }
}
